# FLIM CA Integration: Initialize multiple CAs and evolve them until convergence

This step implements the core innovation of our method: initializing multiple cellular automata (one per FLIM encoder layer) from adaptively decoded feature maps and evolving them to generate refined saliency maps. Each CA eliminates false positives, fills discontinuities, and recovers from initialization failures through foreground and background strength propagation.

**Key Innovation**: Unlike traditional CA methods requiring manual initialization per image, our approach leverages FLIM-encoded domain knowledge for autonomous CA initialization across novel images.

**Performance**: GPU implementation achieves ~27-fold acceleration (from 2.93s to 0.11s per image), making it suitable for resource-constrained clinical environments.

At this point, we get to the core of our method. Given saliencies, adaptively decoded from FLIM-Encoder feature maps, we can initialize a Cellular Automata for each layer, and by evolving them, generate an improved saliency map. The script accepts as input images and saliencies for each layer. For the proper execution, follow the two steps below:

1. Compile the `iftCA.c` code with `./compile.sh 0` to run CA step on CPU. To use the GPU, compile the `iftCAGpu.c` code with `./compile.sh 1`;
2. Given the sample saliencies, run the CA initialization, evolution, and probability map thresholding steps. To achieve it, run the `run_cas.sh` script (for GPU or CPU, accordingly to your previous compilation):


```bash
# For parasite samples - CPU Support
./run_cas.sh /workdir/miscellaneous/parasites/ 0
# For parasite samples - GPU Support
./run_cas.sh /workdir/miscellaneous/parasites/ 1
# For brain samples - CPU Support
./run_cas.sh /workdir/miscellaneous/brain_tumor/ 0
# For brain samples - GPU Support
./run_cas.sh /workdir/miscellaneous/brain_tumor/ 1
```

The script calls either `iftCA` or `iftCAGpu`, with both executions being identical, except for the execution method. To optimize CA evolution, `iftCA` employs **OpenMP**, while `iftCAGpu` tackles evolution where each cell is a thread. The executable gets the following arguments:

1. The input saliencies folder, with FLIM decoded saliencies, which we will employ to initialize CA;
2. The input images folder, which will guide the CA evolution (we compute the similarity between pixels);
3. The input feature folder (feature maps extracted by the FLIM convolutional encoder), which can also guide the CA evolution (the released version does not employ it yet, but future releases will tackle it);
4. Output folder, to save the artifacts generated by the CA execution:
   1. Initialization strengths (for background and foreground);
   2. Evolved strengths;
   3. Label map;
   4. Probability map;
   5. Binary Saliency map, generated after thresholding the probability map;
5. If executing for parasites (0) or brain (1), which correctly defines how CA would be initialized and evolved.

____

## CA Stages

The code for CA execution may be summarized in the following well-defined steps:

1. Reads input saliencies and original images, upsampling or downsampling them to match sizes; initializes foreground and background states (i.e., strengths);
2. Evolution phase;
3. Probability map computation;
4. Thresholding.

Let's dig into each of the CA stages.

> Detailed CA theory and configuration may be found in Chapters 4 and 5.

### 1. Data ingestion & 2. Initialization

Initially, for each sample image, we read the input images and their corresponding saliency maps. For correct evolution, the saliency map employed to initialize the CA and the input image must have the exact spatial dimensions. Size mismatches occur when FLIM encoders contain operations with strides greater than 1. To correctly match sizes, we provide two implementation modes: (0) downsampling the input image to match saliency size; (1) upsampling the saliency map to match image size. Our experiments revealed that downsampling the input image causes loss of crucial spatial information, which degrades CA evolution capability; therefore, mode 1 is the default.

Once size matches, we initialize the CA cell's states (Foreground and background strengths, and label). States are initialized as follows:

1. **Foreground strength** is initialized by dividing the saliency map by 255, hence strength is in the range $[0, 1]$;
2. **Background strength** is initialized differently according to the problem. For the brain, we obtain the brain mask and initialize background strength values: regions outside the brain mask are set to $1$, while brain regions are set to $0$. For parasites, we dilate the saliency map (radius $10$) and employ its complement to initialize the background in the range $[0, 1]$;
3. **Label** is initialized as $1$ if foreground strength is greater than $0$, and as $0$, otherwise.

> Detailed initialization procedures are described in Sections 4.2 and 5.3 of the thesis

### 2. Evolution

Once states are initialized, we evolve them following the algorithm below, until convergence:

**Algorithm: Cellular Automata initialized by FLIM**

**Input:**
- $\mathbf{I}$ - input image, where $\hat{\mathbf{I}} = (D_I, \mathbf{I})$
- $\theta$ - Cells strength, initialized by FLIM, where $\hat{\theta} = (D_\theta, \theta)$
- $ol$ - object label being evolved (0 | 1, background | foreground)
- $LM$ - Cells' current label, where $\hat{LM} = (D_{LM}, LM)$

**Output:** Evolved Cells' strength

**Procedure CA($\mathbf{I}$, $\theta_{ol}^0$, $ol$, $LM$):**

1. $t \gets 0$
2. $dist \gets +\infty$
3. **while** $dist > 10^{-8}$ **do**
4. &nbsp;&nbsp;&nbsp;&nbsp;$\theta_{ol}^{t + 1} \gets \theta_{ol}^{t}$ &nbsp;&nbsp;&nbsp;&nbsp;// Copy previous $\theta$
5. &nbsp;&nbsp;&nbsp;&nbsp;**for all** $p \in D_I$ **do**
6. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$q_{max} \gets \theta_{ol}^t(p)$
7. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**for all** $q \in N_{Moore}(p)$ **do** &nbsp;&nbsp;&nbsp;&nbsp;// Moore neighborhood
8. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$q_{aux} = g(p, q) \times \theta_{ol}^t(q)$
9. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**if** $q_{aux} > q_{max}$ **then**
10. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\theta_{ol}^{t + 1}(p) \gets q_{aux}$
11. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$LM(p) \gets LM(q)$
12. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$q_{max} \gets q_{aux}$
13. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**end if**
14. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**end for**
15. &nbsp;&nbsp;&nbsp;&nbsp;**end for**
16. &nbsp;&nbsp;&nbsp;&nbsp;$dist \gets ||\theta_{ol}^t - \theta_{ol}^{t+1}||_2 / |D_{I}|$
17. &nbsp;&nbsp;&nbsp;&nbsp;$\theta_{ol}^t \gets \theta_{ol}^{t+1}$ &nbsp;&nbsp;&nbsp;&nbsp;// Update step
18. &nbsp;&nbsp;&nbsp;&nbsp;$t \gets t + 1$
19. **end while**
20. **return** $\theta_l^t$

Evolution happens until convergence.

### 3. Probability map

Once evolution has converged, we combine the strengths into a probability map:

$$
O_l (p) = \frac{ln(\theta_{0}^t(p))}{ln(\theta_{0}^t(p)) + ln(\theta_{1}^t(p))}
$$

Where each cell has a value in the range [0, 1] that represents the probability of belonging to the foreground object based on evolved strength values.

### 4. Thresholding

**Parasites:**
- Apply Otsu thresholding to object probability maps
- Binary saliency: $S'_l$ includes pixels where $O_l(p) > \text{Otsu}(O_l)$

**Brain Tumors:**
- Histogram-based statistical analysis within the brain mask
- Focus on upper-intensity spectrum (top 10%) to identify tumor peak in T2-FLAIR images
- Compute mean $\mu$ and standard deviation $\sigma$ in 20% window around peak
- Threshold: $\tau = \mu - k\sigma$ where $k = 2.5$ (empirically determined)
- Binary saliency: pixels with $I(p) \geq \tau$ classified as tumor tissue

**Key Difference:** Otsu thresholding for parasites vs. adaptive statistical thresholding for brain tumors to accommodate T2-FLAIR intensity characteristics.